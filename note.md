# 我最擅长从零开始创造世界，所以从来不怕失败，它最多也就让我一无所有。
## begin learn java
IntelliJ IDEA 注册码 http://idea.lanyus.com/
程序员代码面试指南 IT名企算法与数据结构题目最优解
1. 推荐书单
    http://coredumper.cn/index.php/2017/08/06/java_booklist/
2. java 文档
    https://docs.oracle.com/javase/8/docs/
    
 一：安装
    1. D:\Program Files\Java\jdk1.8.0_151
       D:\javajre
       JAVA_HOME=D:\Program Files\Java\jdk1.8.0_151
       PATH=%JAVA_HOME%\bin;%PATH%;       echo %JAVA_HOME%
       CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar
    2. javac hello.java   ->  java hello 
二：
    1. 创建对象存放在 Garbage-Collectible Heap
    2. 没有全局变量概念
        1. 任何变量加上public static final ，都会变成全局变量取用的常数
        2. 常量pi和random()必须定义在Math类中,很特殊,不会有多个实例或者对象
    3. 成百上千类同时提交
        1. 所有文件存档 jar文件，引入文字文件  manifest ,定义哪个文件带有main函数
三. web应用部署到Tomcat
    1.
四.数据类型 
    primitive 基本数据类型八种
        1.  boolean  ：(一个字节或者四个字节) 计算机最小存储单位
                        声明一个基本变量占四个字节
                        声明一个数组类型时,数组中每个元素占一个字节
            char : 两个字节
        2. integer 整型(带符号) 
            byte 字节 = 8bit    一字节   2^8 = 256
            short(短整型) = 16 bit       2^16 = 655365
            int(整型) = 32bit
            long = 64bit
        3.  float(单精度) 32bit  7个小数位
            double(双精度浮点型) 64bit  15个小数位
        4. 整数没加标识,默认int类型
            以L结尾是long类型数据

五. 基础
    1. 对象引用变量保存的是存取对象的方法
    2. 声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。
    3.变量类型
        类变量：独立于方法之外的变量，用 static 修饰。
        实例变量：独立于方法之外的变量,声明在类中,不过没有 static 修饰。
                  实例变量存在于所属对象中
                  生命周期与对象相同
        局部变量：类的方法中的变量。使用前必须初始化
                  生命周期只限于存在于栈这段期间(被调用至执行完毕)
        参数 ： 类似局部变量
    4.JAVA 的类（外部类）有 2 种访问权限: public、default。
      而方法和变量有 4 种：public、default、protected、private。
      其中默认访问权限和 protected 很相似，有着细微的差别。
       public 意味着任何地方的其他类都能访问。
       default 则是同一个包的类可以访问。
       protected 表示同一个包的类可以访问，其他的包的该类的子类也可以访问。
       private 表示只有自己类能访问
    5.数组初始化
        1. String[] str = {"1","2","3"}; // 正确的  静态初始化
        2. String[] str;
           str = new String[] {"1","2","3"}; // 正确了
        3.  int[] arr = new int[3];  // 动态初始化
            int[] arr1= new int [] {1,2,3,4,5};
            int[] arr2 = {1,2,3,4,5};
        4. 创建Dog类数组 
        5. 数组变量不要记录任何对象内存地址           
    6.
        1. byte可以放进int中，隐含展开implicit widening
        2. 对象：
                状态：实例变量
                行为：方法
        3. 参数跟局部变量一样的,
        4. 方法 void 表示不返回值
        5. java 值传递，即拷贝传递
        6. 
            实例变量永远会有默认值
            局部变量没有默认值
    7. 封装 Encapsulation
        1. 修饰符 access modifier
    8. 极限编程XP
    9. 编写伪码
        1.实例变量声明
        2.方法声明
        3.方法的逻辑
    10. 测试代码
        1.
    11. 真实代码
        1. 
    12. 左脑 ：循序渐进工作,解决逻辑问题与分析,
        右脑 ： 隐喻,创造性思考.模式匹配与可视化
    13. random [0,4）
    14. Dog myDog = new Dog();    引用变量类型
    15.多态
        1. 引用与对象可以是不同类型
        2. 引用类型可以是实际对象类型的父类
        3. 参数和返回类型也可以多态
    16. 三种方式防止类被继承
        1.存取控制,类不能标记私有,非共有的类只能被同一个包类作出子类
        2. final修饰符
        3. private constructor
    17.覆盖父类方法  同名异式
        1.参数一致，返回类型兼容
        2.不能降低方法存取权限
    18. 覆盖的解释
        1. 编译器寻找引用类型决定是否调用该引用特定方法
        2. 执行期寻找的堆上的对象而非引用所指类型
    19.方法重载 overload  (两个方法名称相同,参数不同.重载与多态无关)
        1. 条件：使用不同参数,返回类型可以自由定义
        2. 可以更改存取权限
    20.多态
        1. 继承
        2. 接口 (纯抽象无法初始化类)
    21. 
        1. 抽象类
            如果类带有抽象方法,必须是抽象类
        2. 抽象方法
            public abstract void eat();
        3. 类可以实现多个接口
            public class Dog extends Animal implements Pet{}
        4. 子类覆盖父类方法中调用父类方法
            void runReport(){ super.runReport();}
        5. 所有类都是Object子类
        6. 实现接口必须实现其所有方法
     22.构造器与垃圾回收
        1.(堆栈，范围，构造器，超级构造器，空引用)
        2. 对象生存空间 heap堆
            实例变量存在于对象所属堆空间
        3. 方法调用及变量生存空间stack栈
            对象引用变量及primitive主数据类型都放在栈上
        4. 方法执行放在栈顶，执行完毕被释放掉
     23. 声明对象和赋值 Duck muDuck = new Duck();
        1. 声明引用变量
        2. 创建对象
        3. 连接对象和引用
     24. 构造函数
        1. new Duck(); 实际在调用构造函数
        2. 构造函数必须与类同名且没有返回类型
            (java可以有与类同名方法而不是构造方法)
        3. 构造函数不会被继承
        4. 类可以有多个构造函数
        5, 构造函数可以私有,公有或者不指定
        6. 构造函数中super调用父类构造函数部分
           子类可能会根据父类状态继承方法(即父类实例变量)
           父类构造函数必须执行
           子类构造函数最先调用最后执行
        7. 子类构造函数调用super() 来调用父类构造方法
        8. 每个构造函数都可以调用super()或this(),但不能同时调用
     25. 重载构造函数
        1. 有一个以上构造函数且参数和顺序都不相同
     26. 有参数父类构造函数
     27. 从某个构造函数调用重载版另一个构造函数
        1. 重载版构造函数除了参数不同。代码相同
            所有的构造函数
     28. this
        1. this() 从某个构造函数调用同一个类的另一个构造函数
        2.  this()只能在构造函数中，且必须是第一行
     29. life Scope 引用变量
        1.  life 变量堆栈块还在
        2.  Scope 方法调用其他方法,变量存在,不在当前作用范围
        3.  引用变量只有在处于他的范围才能被引用
    30. 变量生命周期  如何影响对象生命周期
        1. 对象引用不在范围,引用活着,对象继续活在堆上
        2. 唯一引用死了,对象会从堆中踢开,引用变量跟随堆栈块一起解散
    31. 释放对象引用
        1. 引用永久离开他的范围,函数执行结束
        2. 引用被赋值到其他对象上
        3. 直接将引用设定为null

六. IntelliJ 快捷键
    ctrl +alt +T
七. 引用传递和值传递
    1. 数组用的引用传递
    2. 变量使用的值传递
    