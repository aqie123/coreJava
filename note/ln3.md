一：
    a,main
        1.public 保证类在任何情况下,jvm都对其方法可见
        2.static 
            1. 可以使用类名调用
            2. java虚拟机调用main方法不需要创建对象
            3. 创建对象需要的参数可以不用传
            4. void 没有返回值,但是返回也是返回给jvm,jvm对其没作用
            5. main不是关键字,只是特殊标识符
            6. args 形参,某些程序初始化需要参数
二：单例模式
    a.饿汉单例模式(推荐)
        1. 私有化构造函数
        2. 创建本类引用类型变量对象
        3. 提供公共方法获取本类对象
    b.懒汉单例模式(存在线程安全问题)
        1. 私有化构造函数
        2. 声明变量的引用类型变量,但是不创建本类对象
        3. 提供公共方法获取本类对象是我
三：多线程
    1.
四：部分与整体 player team   has a 
    1. 一个对象中 有另一个对象引用
五：继承 animal bird         is a
    1.  私有成员不能被继承
        父类的构造方法也不能被继承
    2. super 关键字 : 代表父类的引用空间(堆内存 在子类中内存空间)
        (必须有无参构造函数 () 2.或者指定调用父类构造函数)
        1. 默认调用父类无参构造方法 
        2. 子类构造函数中 可以指定调用父类有参构造方法
        3. 子父类存在同名的成员时,子类默认访问子类成员,
            可通过super关键字指定访问父类成员变量
        4. 在子类方法中通过super关键字调用父类方法
            编译器会对每个重载版本的构造函数加上下面这种调用
            只会在无参版本加上
        a.堆内存开辟空间专门存储从父类继承的属性
    3. 创建子类会先调用父类无参构造函数,然后调用子类构造函数
    4. 如何创建对象时初始化从父类继承属性
        1. 只有在父类构造方法才能初始化
        2. 需要子类调用父类构造方法实现初始化
            super("aqie","red");
    5. 调用父类构造方法是为了初始化继承
    6. 父类方法无法满足需求.进行【方法重写】 : 子父类存在同名函数 House.java
        1. 子父类函数名和形参列表必须一致
        2. 子类的权限修饰符不能比父类低
        3. 返回类型 子类可以小于或者等于父类
        4. 子类抛出异常类型必须小于或等于父类抛出异常类型
六   关键字
    1. instance : 判断对象是否属于指定类型
        1. 前提：判断对象与指定类型必须存在继承,或者是实现关系
        2. 用处： 多态类型转换前先判断,否则容易报错
    2. final :  Circle.java
        1. 不允许别人修改 pi 使用 private 只提供get方法
        2. final 修饰基本成员变量,该变量不能重新赋值
            常量修饰符 public static final
            常量:所有字母大写,单词与单词下划线,没有默认初始值
            所以常量必须写初始值
        3. final 修饰引用类型变量,其引用不能指向新成员变量
        4. final 修饰方法，该方法不能被重写
        5. final 修饰类时,该类不能被继承
    4. abstract (描述事务某种行为,但是行为不具体) Animal.java 
        1. 一个类有抽象方法,这个类必须是抽象的 abstract 或者 interface
        2. 没有方法体必须用abstract修饰
        3. 非抽象类继承抽象类,必须把抽象类所有方法全部实现
        4. 抽象类可以定义非抽象方法，可以不存在抽象方法
        5. 抽象类无法实例化创建对象：防止调用抽象方法
        6. 抽象类不能创建对象,存在构造方法意义：
            子类调用父类构造函数，初始化从父类继承下的属性
        7. 不能与以下关键字配合使用
            private, final, static(类名调用抽象方法没意义)
七 note
    1. 一个方法运行会在栈内存开辟独立的空间
    2. 局部变量与局部变量是相互独立的
    3. java 支持多实现接口，为什么不支持多继承
        1. 两个父类同名方法 会冲突
        2. 
    4. 强制类型转换错误： ClassCastException
        1. 强制类型转换前 先使用 instanceof
    5. private修饰的后的成员只能在本类中被访问
        
八,值交换
    1. 调用方法时,传递给方法是变量存储的值
    2. (两个方法局部变量相互独立)
    3. 对象虽然引用变量是两个，但是指向的是同一个对象(包括数组)
九,接口interface  Student.java
    1. 接口是一个特殊类
    2. 接口里面成员变量都是常量 默认修饰符 public static final
    3. 接口类中方法不能有方法体,都是抽象方法 public abstract 
    4. 【非抽象类实现接口】 必须实现接口所有方法
    5. 接口没有构造方法,都是常量不需要初始化,都是抽象方法
    6. 作用：
        1. 拓展功能
        2. 定义约束规范
        3. 程序解耦 (低耦合 高内聚)
    7. 抽象类实现接口不需要实现所有方法
    8. 接口和接口是继承关系,一个接口可以继承多个接口
    9. 接口不存在静态方法 ，接口方法全是抽象 abstract
十，反编译
    1. javap -c -l -p  Computer  : 反编译 Computer.class 
十一：内部类 ： 一个类内部定义另外一个类，则另外一个类叫内部类
    1. 类型
        1. 成员内部类
        2. 方法内定义类： 局部内部类
    2. 没有静态(static)的类中类不能使用外部类进行.操作,必须用实例来进行实例化类中类.
    3.访问方式
        1. Outer outer = new Outer(); Outer.Inner inner =outer.new Inner();
        2. 通过外部类方法中实例化内部类
        3. 内部类有static  
            Outer.Inner inner =new Outer.Inner();
        4. 内部类有private 不能外部直接访问
        5. 
    4. 好处
        1. 
    5.注意
        1. 直接访问外部类所有成员
        2. 内部类方法 访问外部类成员
             Outer.this.name 
           内部类有static
        3. 私有的成员内部类只能通过外部类中的公共方法访问,其他类无法访问
        4. 如果一个成员内部类定义了静态成员,该类也必须使用static
            1.因为 静态成员变量不依赖对象而存在
    6. 局部内部类 ： 方法内部定义类称为局部内部类 Outer2.java
        注意：
            1.局部内部类访问局部变量,局部变量必须用final修饰。 java8不需要
    7. 匿名内部类 ： 没有类名的内部类 Outer3.java
        1. 前提：必须存在继承或者实现
        2. 好处：
            1. 简化书写
            2. 
        3. 方法调用 
            1. new Animal{}.run();
            2. 或者使用变量接收 Animal f = Animal{}.run();
        4. 普通和抽象类都可以有匿名类
        5. 实现关系也可以有匿名类