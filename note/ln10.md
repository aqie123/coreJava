一：静态导入  Demo21.java
    1.作用 ：简化书写 import static 包名.类名.静态成员
    2, 仅针对类的静态成员
    3. 导入
二：增强for循环   Demo21.java  method4
    1.作用 ：简化迭代器书写方式
    2. 格式 ： for(int ele : data)
    3. 前提：实现 Iterable接口对象或者是数组
    4. 注意：
        1.迭代器迭代过程中 不能使用集合对象改变元素个数 (add remove)
        2. 底层还是通过获取迭代器方式进行遍历,不需要手动获取迭代器
    5.增强for循环与迭代器遍历区别
        1. for循环不能增删,迭代器遍历可以使用迭代器方式增删元素
    6. 和普通for循环区别
        1.必须有遍历目标
三：note
    1.开发中一个集合对象只会存储同一种类型数据
四：自定义类实现Iterable接口  Demo22.java
五 ：可变参数  Demo23.java
    1. 格式  ... 变量名
    2, 注意
        1.函数形参使用可变参数，调用该函数可传递参数也可以不传递
        2. 可变参数实际就是个数组，
        3. 函数使用可变参数，传递数据时，jvm自动把数据保存到数组中
        4. 可变参数位于形参的最后位置
六：自动装箱  自动拆箱  Demo23.java  method3()
    1. 描述基本类型变量的类成为包装类
    2. 包装类好处 ： 
        1. 可以让基本数据类型也使用方法
    3. 集合：存储任意类型对象的容器
    4. 自动装箱
        1.自动把基本数据类型转成引用数据类型
    5. 自动拆箱 ： 自动把引用数据类型数据转换成 基本类型数据
七：Integer    method4()
    1. Integer 内部维护了静态数组,内部存储了 -128-127
        当创建对象时 在 -128-127 会直接从数组中获取，不会创建新的对象
        目的 ： 节省内存空间 提高效率
        享元模式：常用数据事先创建好,供大家一起用
八：枚举类  Demo24.java   
    1. 方法运行时,需要的数据不是任意的,必须是一定范围内的值
    2. 枚举值 默认修饰符 public static final   常量 
    3. 枚举值是当前枚举类的对象
    4. 枚举值必须位于类的第一个位置
    5. 枚举类构造方法默认修饰符 private
    6. 枚举类允许出现抽象方法, 出现抽象方法,枚举值必须实现
    7. switch 适用类型 ： byte,short,int char,String 枚举类型
        switch 语句适用枚举类，case后面不能跟枚举类  直接写枚举值
九：正则  Demo25.java
     a.   预定义字符类 
            . 	任何字符（与行结束符可能匹配也可能不匹配） 
            \d 	数字：[0-9] 
            \D 	非数字： [^0-9] 
            \s 	空白字符：[ \t\n\x0B\f\r] 
            \S 	非空白字符：[^\s] 
            \w 	单词字符：[a-zA-Z_0-9] 
            \W 	非单词字符：[^\w]
        Greedy 数量词   
            X?	X，一次或一次也没有
            X*	X，零次或多次
            X+	X，一次或多次
            X{n}	X，恰好n次
            X{n,}	X，至少n次
            X{n,m}	X，至少n次，但是不超过m次
        范围表示    
            [abc]	a、b 或 c（简单类） 
            [^abc]	任何字符，除了 a、b 或 c（否定） 
            [a-zA-Z]	a 到 z 或 A 到 Z，两头的字母包括在内（范围） 
            [a-d[m-p]]	a 到 d 或 m 到 p：[a-dm-p]（并集） 
            [a-z&&[def]]	d、e 或 f（交集） 
            [a-z&&[^bc]]	a 到 z，除了 b 和 c：[ad-z]（减去） 
            [a-z&&[^m-p]]	a 到 z，而非 m 到 p：[a-lq-z]（减去）
            ^ 	行的开头 
            $ 	行的结尾 
            \b 	单词边界 
            \B 	非单词边界 
            \A 	输入的开头 
            \G 	上一个匹配的结尾 
            \Z 	输入的结尾，仅用于最后的结束符（如果有的话） 
            \z 	输入的结尾
     b. 匹配
        matches
     c. 切割
        split
     d. 替换
        replaceAll
     e. 获取
        正则对象 Pattern  匹配器 Matcher
        步骤：
        	1，先将正则表达式编译成正则对象。使用的是Pattern类一个静态的方法。compile(regex);
        	2，让正则对象和要操作的字符串相关联，通过matcher方法完成，并返回匹配器对象。
        	3，通过匹配器对象的方法将正则模式作用到字符串上对字符串进行针对性的功能操作
        





